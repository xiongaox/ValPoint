<!DOCTYPE html>
<html lang="zh-CN">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Reticle - 瓦罗兰特瞄点编辑器</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css" rel="stylesheet">
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&display=swap" rel="stylesheet">
    <link href="https://fonts.googleapis.com/css2?family=Oswald:wght@500;700&display=swap" rel="stylesheet">
    <style>
        :root {
            --accent-color: #ef4444;
            --bg-dark: #0f0f11;
            --panel-bg: rgba(20, 20, 23, 0.85);
            --card-bg: rgba(255, 255, 255, 0.03);
            --card-hover: rgba(255, 255, 255, 0.06);
            --border-color: rgba(255, 255, 255, 0.08);
        }

        body {
            background-color: var(--bg-dark);
            color: #e5e5e5;
            font-family: 'Inter', system-ui, -apple-system, sans-serif;
            background-image: radial-gradient(circle at 50% 0%, #2a1b1b 0%, #0f0f11 60%);
        }

        /* Modern Range Slider */
        input[type=range] {
            -webkit-appearance: none;
            appearance: none;
            width: 100%;
            background: transparent;
        }

        input[type=range]:focus {
            outline: none;
        }

        /* Track */
        input[type=range]::-webkit-slider-runnable-track {
            width: 100%;
            height: 4px;
            cursor: pointer;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 999px;
            transition: background 0.2s;
        }

        input[type=range]:hover::-webkit-slider-runnable-track {
            background: rgba(255, 255, 255, 0.15);
        }

        /* Thumb */
        input[type=range]::-webkit-slider-thumb {
            -webkit-appearance: none;
            height: 16px;
            width: 16px;
            border-radius: 50%;
            background: var(--thumb-color, #ef4444);
            /* Dynamic Color */
            cursor: pointer;
            margin-top: -6px;
            box-shadow: 0 0 0 4px rgba(255, 255, 255, 0.1);
            transition: transform 0.1s, box-shadow 0.2s;
        }

        input[type=range]::-webkit-slider-thumb:hover {
            transform: scale(1.1);
            box-shadow: 0 0 0 6px rgba(255, 255, 255, 0.2);
        }

        /* Color Input Reset */
        input[type="color"] {
            -webkit-appearance: none;
            appearance: none;
            border: none;
            padding: 0;
            width: 24px;
            height: 24px;
            border-radius: 50%;
            overflow: hidden;
            cursor: pointer;
            background: none;
        }

        input[type="color"]::-webkit-color-swatch-wrapper {
            padding: 0;
        }

        input[type="color"]::-webkit-color-swatch {
            border: 2px solid rgba(255, 255, 255, 0.2);
            border-radius: 50%;
        }

        /* Canvas Background Pattern */
        .canvas-bg {
            background-image:
                linear-gradient(45deg, #1f1f22 25%, transparent 25%),
                linear-gradient(-45deg, #1f1f22 25%, transparent 25%),
                linear-gradient(45deg, transparent 75%, #1f1f22 75%),
                linear-gradient(-45deg, transparent 75%, #1f1f22 75%);
            background-size: 20px 20px;
            background-position: 0 0, 0 10px, 10px -10px, -10px 0px;
            background-color: #161618;
        }

        /* Glass Panel */
        .glass-panel {
            background: var(--panel-bg);
            backdrop-filter: blur(12px);
            -webkit-backdrop-filter: blur(12px);
            border-top: 1px solid var(--border-color);
        }

        /* Card Style */
        .control-card {
            background: var(--card-bg);
            border: 1px solid var(--border-color);
            border-radius: 12px;
            transition: all 0.2s ease;
        }

        .control-card:hover {
            background: var(--card-hover);
            border-color: rgba(255, 255, 255, 0.15);
        }

        /* Custom Scrollbar */
        ::-webkit-scrollbar {
            width: 6px;
            height: 6px;
        }

        ::-webkit-scrollbar-track {
            background: transparent;
        }

        ::-webkit-scrollbar-thumb {
            background: rgba(255, 255, 255, 0.1);
            border-radius: 3px;
        }

        ::-webkit-scrollbar-thumb:hover {
            background: rgba(255, 255, 255, 0.2);
        }

        .loader {
            border: 3px solid rgba(255, 255, 255, 0.1);
            border-radius: 50%;
            border-top: 3px solid #ef4444;
            width: 32px;
            height: 32px;
            animation: spin 0.8s linear infinite;
        }

        @keyframes spin {
            0% {
                transform: rotate(0deg);
            }

            100% {
                transform: rotate(360deg);
            }
        }
    </style>
</head>

<body class="h-screen flex flex-col overflow-hidden text-sm selection:bg-red-500/30">

    <!-- Header -->
    <header
        class="h-14 px-6 flex justify-between items-center shrink-0 z-20 border-b border-white/5 bg-black/20 backdrop-blur-sm">
        <div class="flex items-center gap-3">
            <!-- Logo Icon -->
            <div
                class="w-8 h-8 rounded bg-gradient-to-br from-red-600 to-red-800 flex items-center justify-center text-white shadow-[0_0_15px_rgba(239,68,68,0.4)] border border-white/10">
                <i class="fas fa-crosshairs text-sm"></i>
            </div>
            <!-- Title Group -->
            <div class="flex flex-col justify-center">
                <h1 class="font-['Oswald'] font-bold tracking-wider text-lg leading-none uppercase text-white">
                    Reticle <span class="text-red-500 text-[10px] align-top ml-0.5">BETA</span>
                </h1>
                <p class="text-[10px] text-gray-500 font-medium tracking-widest uppercase scale-90 origin-left">
                    瓦罗兰特点位编辑器</p>
            </div>
        </div>

        <!-- Right Action Buttons -->
        <div class="flex items-center gap-3">
            <button id="upload-btn-header"
                class="bg-white/5 hover:bg-white/10 text-gray-300 rounded-lg border border-white/10 transition-all flex items-center justify-center gap-2 px-3 py-1.5 text-xs font-medium h-8 hover:border-white/20">
                <i class="fas fa-sync-alt"></i> <span class="hidden sm:inline">换图</span>
            </button>
            <button id="paste-btn-header"
                class="bg-white/5 hover:bg-white/10 text-gray-300 rounded-lg border border-white/10 transition-all flex items-center justify-center gap-2 px-3 py-1.5 text-xs font-medium h-8 hover:border-white/20"
                title="从剪贴板粘贴图片 (Ctrl+V)">
                <i class="fas fa-paste"></i> <span class="hidden sm:inline">粘贴</span>
            </button>
            <button id="copy-btn-header"
                class="bg-white/5 hover:bg-white/10 text-gray-300 rounded-lg border border-white/10 transition-all flex items-center justify-center gap-2 px-3 py-1.5 text-xs font-medium h-8 hover:border-white/20 disabled:opacity-50 disabled:cursor-not-allowed">
                <i class="fas fa-copy"></i> <span class="hidden sm:inline">复制</span>
            </button>
            <button id="download-btn-header"
                class="bg-gradient-to-r from-red-600 to-red-700 hover:from-red-500 hover:to-red-600 text-white rounded-lg shadow-[0_4px_12px_rgba(220,38,38,0.3)] border border-white/10 transition-all transform active:scale-95 flex items-center justify-center gap-2 px-4 py-1.5 text-xs font-bold tracking-wide disabled:opacity-50 disabled:cursor-not-allowed h-8">
                <i class="fas fa-download"></i> <span class="hidden sm:inline">保存</span>
            </button>
        </div>
    </header>

    <!-- Main Content -->
    <main class="flex-1 flex flex-col overflow-hidden relative">

        <!-- Canvas Area -->
        <div class="flex-1 relative flex items-center justify-center p-6 overflow-hidden group" id="canvas-wrapper">

            <!-- Empty State -->
            <div id="empty-state"
                class="text-center p-12 border border-dashed border-white/10 rounded-2xl bg-white/5 hover:bg-white/10 hover:border-red-500/50 transition-all cursor-pointer group-hover:shadow-2xl shadow-black/50 backdrop-blur-sm">
                <div
                    class="w-16 h-16 bg-white/5 rounded-full flex items-center justify-center mx-auto mb-4 group-hover:scale-110 transition-transform duration-300 ring-1 ring-white/10">
                    <i class="fas fa-image text-2xl text-gray-400 group-hover:text-red-500 transition-colors"></i>
                </div>
                <h3 class="text-lg font-semibold text-gray-200">点击上传图片</h3>
                <p class="text-gray-500 text-xs mt-1">支持 JPG, PNG, WEBP (Max 20MB)</p>
                <input type="file" id="file-upload" class="hidden" accept="image/*">
            </div>

            <!-- Canvas Wrapper -->
            <div id="canvas-box"
                class="hidden shadow-[0_20px_50px_-12px_rgba(0,0,0,0.5)] rounded-sm overflow-hidden border border-white/5 canvas-bg relative">
                <canvas id="editor-canvas" class="block"></canvas>
                <div id="loading-overlay"
                    class="absolute inset-0 bg-black/60 hidden items-center justify-center z-50 backdrop-blur-sm">
                    <div class="loader"></div>
                </div>
            </div>

        </div>

        <!-- Controls Panel (Glassmorphism) -->
        <section class="glass-panel shrink-0 z-30 h-auto overflow-y-auto custom-scroll">
            <div class="max-w-[1600px] mx-auto p-4 md:p-6">
                <!-- 4 Column Grid -->
                <div class="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-4 gap-4">

                    <!-- Col 1: Lens Settings -->
                    <div class="control-card p-4 flex flex-col gap-4 h-full">
                        <div class="flex items-center justify-between border-b border-white/5 pb-2">
                            <div class="flex items-center gap-2 text-gray-400">
                                <i class="fas fa-crosshairs text-xs"></i>
                                <span class="text-xs font-bold uppercase tracking-wider">镜头参数</span>
                            </div>
                            <!-- Updated: Capsule Style Lock Button -->
                            <button id="btn-lock"
                                class="group flex items-center gap-1.5 px-3 py-1 rounded-full bg-red-500/20 border border-red-500/30 text-red-400 hover:bg-red-500 hover:text-white transition-all text-[10px] font-medium shadow-[0_0_10px_rgba(239,68,68,0.1)] hover:shadow-[0_0_15px_rgba(239,68,68,0.3)]">
                                <i class="fas fa-lock text-[10px]"></i>
                                <span>位置锁定</span>
                            </button>
                        </div>

                        <div class="space-y-4">
                            <!-- Zoom -->
                            <div class="grid grid-cols-[32px_1fr_40px] gap-3 items-center">
                                <span class="text-xs text-gray-500 font-medium">倍率</span>
                                <input type="range" id="param-zoom" min="1.1" max="5.0" step="0.1" value="3.0">
                                <span id="val-zoom" class="text-xs font-mono text-gray-300 text-right">3.0x</span>
                            </div>
                            <!-- Size -->
                            <div class="grid grid-cols-[32px_1fr_40px] gap-3 items-center">
                                <span class="text-xs text-gray-500 font-medium">尺寸</span>
                                <input type="range" id="param-size" min="100" max="400" step="10" value="280">
                                <span id="val-size" class="text-xs font-mono text-gray-300 text-right">280</span>
                            </div>
                            <!-- Aim Radius -->
                            <div class="grid grid-cols-[32px_1fr_40px] gap-3 items-center">
                                <span class="text-xs text-gray-500 font-medium">准心</span>
                                <input type="range" id="param-aim" min="5" max="100" step="1" value="16">
                                <span id="val-aim" class="text-xs font-mono text-gray-300 text-right">16</span>
                            </div>
                        </div>
                    </div>

                    <!-- Col 2: Style Settings -->
                    <div class="control-card p-4 flex flex-col gap-4 h-full">
                        <div class="flex items-center justify-between border-b border-white/5 pb-2">
                            <div class="flex items-center gap-2 text-gray-400">
                                <i class="fas fa-paint-brush text-xs"></i>
                                <span class="text-xs font-bold uppercase tracking-wider">样式设置</span>
                            </div>
                            <div class="flex items-center gap-2">
                                <span class="text-[10px] text-gray-500">颜色</span>
                                <input type="color" id="param-color" value="#ef4444" title="主题颜色">
                            </div>
                        </div>

                        <div class="space-y-4">
                            <!-- Border Width -->
                            <div class="grid grid-cols-[48px_1fr_30px] gap-3 items-center">
                                <span class="text-xs text-gray-500 font-medium">框粗细</span>
                                <input type="range" id="param-border-w" min="1" max="20" step="1" value="6">
                                <span id="val-border-w" class="text-xs font-mono text-gray-300 text-right">6</span>
                            </div>
                            <!-- Aim Width -->
                            <div class="grid grid-cols-[48px_1fr_30px] gap-3 items-center">
                                <span class="text-xs text-gray-500 font-medium">准粗细</span>
                                <input type="range" id="param-aim-w" min="1" max="10" step="1" value="4">
                                <span id="val-aim-w" class="text-xs font-mono text-gray-300 text-right">4</span>
                            </div>
                        </div>
                    </div>

                    <!-- Col 3: Drawing Tools -->
                    <div class="control-card p-4 flex flex-col gap-4 h-full">
                        <div class="flex items-center justify-between border-b border-white/5 pb-2">
                            <div class="flex items-center gap-2 text-gray-400">
                                <i class="fas fa-pencil-alt text-xs"></i>
                                <span class="text-xs font-bold uppercase tracking-wider">图形编辑</span>
                            </div>
                            <button id="btn-clear-shapes"
                                class="text-[10px] text-gray-500 hover:text-red-400 transition-colors flex items-center gap-1">
                                <i class="fas fa-trash-alt"></i> 全部清除
                            </button>

                        </div>

                        <!-- Tool Buttons -->
                        <div class="flex flex-wrap gap-2">
                            <button type="button" data-tool="rect" title="矩形"
                                class="draw-tool-btn w-9 h-9 rounded-lg flex items-center justify-center transition-all bg-white/5 border border-white/10 text-gray-400 hover:bg-white/10 hover:text-gray-200">
                                <i class="far fa-square"></i>
                            </button>
                            <button type="button" data-tool="circle" title="圆形"
                                class="draw-tool-btn w-9 h-9 rounded-lg flex items-center justify-center transition-all bg-white/5 border border-white/10 text-gray-400 hover:bg-white/10 hover:text-gray-200">
                                <i class="far fa-circle"></i>
                            </button>
                            <button type="button" data-tool="line" title="直线"
                                class="draw-tool-btn w-9 h-9 rounded-lg flex items-center justify-center transition-all bg-white/5 border border-white/10 text-gray-400 hover:bg-white/10 hover:text-gray-200">
                                <i class="fas fa-minus" style="transform: rotate(-45deg)"></i>
                            </button>
                            <button type="button" data-tool="arrow" title="箭头"
                                class="draw-tool-btn w-9 h-9 rounded-lg flex items-center justify-center transition-all bg-white/5 border border-white/10 text-gray-400 hover:bg-white/10 hover:text-gray-200">
                                <i class="fas fa-long-arrow-alt-up" style="transform: rotate(45deg)"></i>
                            </button>
                            <button type="button" data-tool="arrow-grow" title="渐变箭头"
                                class="draw-tool-btn w-9 h-9 rounded-lg flex items-center justify-center transition-all bg-white/5 border border-white/10 text-gray-400 hover:bg-white/10 hover:text-gray-200">
                                <i class="fas fa-location-arrow"></i>
                            </button>
                            <button type="button" data-tool="pen" title="画笔"
                                class="draw-tool-btn w-9 h-9 rounded-lg flex items-center justify-center transition-all bg-white/5 border border-white/10 text-gray-400 hover:bg-white/10 hover:text-gray-200">
                                <i class="fas fa-pen"></i>
                            </button>
                            <button type="button" data-tool="polyline" title="连续直线 (右键结束)"
                                class="draw-tool-btn w-9 h-9 rounded-lg flex items-center justify-center transition-all bg-white/5 border border-white/10 text-gray-400 hover:bg-white/10 hover:text-gray-200">
                                <i class="fas fa-bezier-curve"></i>
                            </button>
                            <button type="button" data-tool="eraser" title="橡皮擦"
                                class="draw-tool-btn w-9 h-9 rounded-lg flex items-center justify-center transition-all bg-white/5 border border-white/10 text-gray-400 hover:bg-white/10 hover:text-gray-200">
                                <i class="fas fa-eraser"></i>
                            </button>

                            <div class="flex items-center gap-3">
                                <div class="flex items-center gap-2">
                                    <span class="text-[10px] text-gray-500">颜色</span>
                                    <input type="color" id="draw-color" value="#ef4444" title="绘图颜色">
                                </div>
                                <div class="flex-1 flex items-center gap-2">
                                    <span class="text-[10px] text-gray-500">粗细</span>
                                    <input type="range" id="draw-stroke-width" min="1" max="12" step="1" value="3"
                                        class="flex-1">
                                    <span id="val-draw-stroke"
                                        class="text-xs font-mono text-gray-300 w-4 text-right">3</span>
                                </div>
                                <div class="flex-1 flex items-center gap-2">
                                    <span class="text-[10px] text-gray-500">箭头</span>
                                    <input type="range" id="draw-arrow-size" min="10" max="50" step="2" value="24"
                                        class="flex-1">
                                    <span id="val-arrow-size"
                                        class="text-xs font-mono text-gray-300 w-5 text-right">24</span>
                                </div>
                            </div>
                        </div>
                    </div>

                    <!-- Col 4: Export Settings -->
                    <div class="control-card p-4 flex flex-col gap-4 h-full">
                        <div class="flex items-center gap-2 text-gray-400 border-b border-white/5 pb-2">
                            <i class="fas fa-sliders-h text-xs"></i>
                            <span class="text-xs font-bold uppercase tracking-wider">输出设置</span>
                        </div>
                        <div class="space-y-4">
                            <div class="grid grid-cols-[32px_1fr_40px] gap-3 items-center">
                                <span class="text-xs text-gray-500 font-medium">画质</span>
                                <input type="range" id="param-quality" min="10" max="100" step="5" value="80">
                                <span id="val-quality" class="text-xs font-mono text-gray-300 text-right">80%</span>
                            </div>
                            <div class="grid grid-cols-[32px_1fr_40px] gap-3 items-center">
                                <span class="text-xs text-gray-500 font-medium">缩放</span>
                                <input type="range" id="param-scale" min="0.1" max="1.0" step="0.1" value="1.0">
                                <span id="val-scale" class="text-xs font-mono text-gray-300 text-right">100%</span>
                            </div>
                            <!-- Format Selector -->
                            <div class="grid grid-cols-[32px_1fr] gap-3 items-center">
                                <span class="text-xs text-gray-500 font-medium">格式</span>
                                <div class="flex items-center gap-2" id="format-btns">
                                    <button type="button" data-format="png"
                                        class="format-btn px-3 py-1 rounded-lg text-[10px] font-medium transition-all bg-red-500/20 border border-red-500/30 text-red-400 shadow-[0_0_10px_rgba(239,68,68,0.1)]">PNG</button>
                                    <button type="button" data-format="jpg"
                                        class="format-btn px-3 py-1 rounded-lg text-[10px] font-medium transition-all bg-white/5 border border-white/10 text-gray-400 hover:bg-white/10 hover:text-gray-200">JPG</button>
                                    <button type="button" data-format="webp"
                                        class="format-btn px-3 py-1 rounded-lg text-[10px] font-medium transition-all bg-white/5 border border-white/10 text-gray-400 hover:bg-white/10 hover:text-gray-200">WebP</button>
                                </div>
                            </div>
                        </div>
                    </div>

                </div>
            </div>
        </section>
    </main>

    <script>
        // --- State Management ---
        const state = {
            image: null,
            canvasScale: 1,
            fileName: null,
            fileType: null,

            lens: {
                x: 8,
                y: 8,
                radius: 140, // 280 / 2
                zoom: 3.0,
                aimRadius: 16,
                // New Style Params
                borderWidth: 6,
                aimWidth: 4,
                borderColor: '#ef4444'
            },

            // Drawing State
            drawing: {
                currentTool: null, // 'rect', 'circle', 'line', 'arrow', 'pen'
                color: '#ef4444',
                strokeWidth: 3,
                arrowSize: 24,     // Arrow head size
                shapes: [],        // Array of completed shapes
                isDrawing: false,
                startX: 0,
                startY: 0,
                currentPath: [],   // For pen tool
                isPolylineActive: false // For polyline tool
            },

            target: { x: 0, y: 0 },

            isLensLocked: true,
            isDraggingLens: false,
            isDraggingContent: false,
            lastMouse: { x: 0, y: 0 },
            exportFormat: 'png'  // Default export format
        };

        // --- DOM Elements ---
        const els = {
            fileInput: document.getElementById('file-upload'),
            emptyState: document.getElementById('empty-state'),
            uploadBtn: document.getElementById('upload-btn-header'),
            pasteBtn: document.getElementById('paste-btn-header'),
            downloadBtn: document.getElementById('download-btn-header'),
            copyBtn: document.getElementById('copy-btn-header'),

            canvasBox: document.getElementById('canvas-box'),
            canvas: document.getElementById('editor-canvas'),
            canvasWrapper: document.getElementById('canvas-wrapper'),

            btnLock: document.getElementById('btn-lock'),

            // Params
            zoom: document.getElementById('param-zoom'),
            size: document.getElementById('param-size'),
            aim: document.getElementById('param-aim'),
            quality: document.getElementById('param-quality'),
            scale: document.getElementById('param-scale'),

            // New Style Inputs
            borderW: document.getElementById('param-border-w'),
            aimW: document.getElementById('param-aim-w'),
            color: document.getElementById('param-color'),

            // Drawing Tools
            drawColor: document.getElementById('draw-color'),
            drawStrokeWidth: document.getElementById('draw-stroke-width'),
            drawArrowSize: document.getElementById('draw-arrow-size'),
            btnClearShapes: document.getElementById('btn-clear-shapes'),

            // Labels
            valZoom: document.getElementById('val-zoom'),
            valSize: document.getElementById('val-size'),
            valAim: document.getElementById('val-aim'),
            valQuality: document.getElementById('val-quality'),
            valScale: document.getElementById('val-scale'),
            valBorderW: document.getElementById('val-border-w'),
            valAimW: document.getElementById('val-aim-w'),
            valDrawStroke: document.getElementById('val-draw-stroke'),
            valArrowSize: document.getElementById('val-arrow-size'),
        };

        const ctx = els.canvas.getContext('2d');

        // --- Initialization ---
        function init() {
            els.emptyState.addEventListener('click', () => els.fileInput.click());
            els.uploadBtn.addEventListener('click', () => els.fileInput.click());
            els.pasteBtn.addEventListener('click', handlePasteFromClipboard);
            els.fileInput.addEventListener('change', handleFileSelect);

            // 全局 Ctrl+V 粘贴监听
            document.addEventListener('paste', handlePasteEvent);

            els.canvas.addEventListener('mousedown', handleMouseDown);
            window.addEventListener('mousemove', handleMouseMove);
            window.addEventListener('mouseup', handleMouseUp);

            els.canvas.addEventListener('touchstart', handleTouchStart, { passive: false });
            window.addEventListener('touchmove', handleTouchMove, { passive: false });
            window.addEventListener('touchend', handleMouseUp);
            window.addEventListener('touchend', handleMouseUp);
            els.canvas.addEventListener('contextmenu', handleContextMenu);
            window.addEventListener('keydown', handleKeyDown);

            els.btnLock.addEventListener('click', toggleLock);

            // Event Listeners for all inputs
            const inputs = [
                els.zoom, els.size, els.aim, els.quality, els.scale,
                els.borderW, els.aimW, els.color,
                els.drawColor, els.drawStrokeWidth, els.drawArrowSize
            ];

            inputs.forEach(input => {
                input.addEventListener('input', () => {
                    updateParams();
                });
            });

            els.downloadBtn.addEventListener('click', downloadImage);
            els.downloadBtn.disabled = true;
            els.copyBtn.addEventListener('click', copyImage);
            els.copyBtn.disabled = true;

            // Drawing tool buttons
            document.querySelectorAll('.draw-tool-btn').forEach(btn => {
                btn.addEventListener('click', () => {
                    const tool = btn.dataset.tool;
                    if (state.drawing.currentTool === tool) {
                        // Deselect if clicking the same tool
                        // If polyline was active, cancel it
                        if (state.drawing.currentTool === 'polyline' && state.drawing.isPolylineActive) {
                            state.drawing.isPolylineActive = false;
                            state.drawing.currentPath = [];
                            render();
                        }
                        state.drawing.currentTool = null;
                    } else {
                        // Switching tool, reset polyline if active
                        if (state.drawing.isPolylineActive) {
                            state.drawing.isPolylineActive = false;
                            state.drawing.currentPath = [];
                            render();
                        }
                        state.drawing.currentTool = tool;
                    }
                    updateToolButtonStyles();
                });
            });

            // Clear shapes button
            els.btnClearShapes.addEventListener('click', () => {
                state.drawing.shapes = [];
                render();
            });

            // Format toggle buttons
            document.querySelectorAll('.format-btn').forEach(btn => {
                btn.addEventListener('click', () => {
                    state.exportFormat = btn.dataset.format;
                    // Update button styles
                    document.querySelectorAll('.format-btn').forEach(b => {
                        if (b === btn) {
                            b.className = 'format-btn px-3 py-1 rounded-lg text-[10px] font-medium transition-all bg-red-500/20 border border-red-500/30 text-red-400 shadow-[0_0_10px_rgba(239,68,68,0.1)]';
                        } else {
                            b.className = 'format-btn px-3 py-1 rounded-lg text-[10px] font-medium transition-all bg-white/5 border border-white/10 text-gray-400 hover:bg-white/10 hover:text-gray-200';
                        }
                    });
                });
            });

            window.addEventListener('resize', () => {
                if (state.image) {
                    setupCanvas();
                    render();
                }
            });
        }

        // --- Logic ---
        function handleFileSelect(e) {
            const file = e.target.files[0];
            if (!file) return;

            const reader = new FileReader();
            reader.onload = (event) => {
                const img = new Image();
                img.onload = () => {
                    state.image = img;
                    setupCanvas();

                    state.lens.x = 8;
                    state.lens.y = 8;
                    state.target.x = img.width / 2;
                    state.target.y = img.height / 2;
                    state.fileName = file.name || null;
                    state.fileType = file.type || null;

                    render();
                    els.emptyState.classList.add('hidden');
                    els.canvasBox.classList.remove('hidden');
                    els.downloadBtn.disabled = false;
                    els.copyBtn.disabled = false;
                };
                img.src = event.target.result;
            };
            reader.readAsDataURL(file);
        }

        // 处理粘贴事件（Ctrl+V）
        function handlePasteEvent(e) {
            const items = e.clipboardData?.items;
            if (!items) return;

            for (const item of items) {
                if (item.type.startsWith('image/')) {
                    e.preventDefault();
                    const file = item.getAsFile();
                    if (file) loadImageFromFile(file);
                    return;
                }
            }
        }

        // 点击粘贴按钮，从剪贴板读取图片
        async function handlePasteFromClipboard() {
            if (!navigator.clipboard || !navigator.clipboard.read) {
                alert('当前浏览器不支持剪贴板读取，请尝试使用 Ctrl+V 粘贴。');
                return;
            }

            try {
                const clipboardItems = await navigator.clipboard.read();
                for (const item of clipboardItems) {
                    const imageType = item.types.find(type => type.startsWith('image/'));
                    if (imageType) {
                        const blob = await item.getType(imageType);
                        loadImageFromFile(blob);
                        return;
                    }
                }
                alert('剪贴板中没有图片。');
            } catch (err) {
                // 可能是权限问题
                if (err.name === 'NotAllowedError') {
                    alert('请允许访问剪贴板，或使用 Ctrl+V 粘贴。');
                } else {
                    alert('读取剪贴板失败：' + err.message);
                }
            }
        }

        // 从 File/Blob 加载图片（复用逻辑）
        function loadImageFromFile(file) {
            const reader = new FileReader();
            reader.onload = (event) => {
                const img = new Image();
                img.onload = () => {
                    state.image = img;
                    setupCanvas();

                    state.lens.x = 8;
                    state.lens.y = 8;
                    state.target.x = img.width / 2;
                    state.target.y = img.height / 2;
                    state.fileName = file.name || 'clipboard_image';
                    state.fileType = file.type || 'image/png';

                    render();
                    els.emptyState.classList.add('hidden');
                    els.canvasBox.classList.remove('hidden');
                    els.downloadBtn.disabled = false;
                    els.copyBtn.disabled = false;
                };
                img.src = event.target.result;
            };
            reader.readAsDataURL(file);
        }

        function setupCanvas() {
            if (!state.image) return;
            const wrapper = els.canvasWrapper;
            const maxWidth = wrapper.clientWidth - 48; // p-6 * 2
            const maxHeight = wrapper.clientHeight - 48;

            const imgRatio = state.image.width / state.image.height;
            const containerRatio = maxWidth / maxHeight;

            let finalWidth, finalHeight;

            if (imgRatio > containerRatio) {
                finalWidth = maxWidth;
                finalHeight = maxWidth / imgRatio;
            } else {
                finalHeight = maxHeight;
                finalWidth = maxHeight * imgRatio;
            }

            els.canvas.width = finalWidth;
            els.canvas.height = finalHeight;
            els.canvas.style.width = finalWidth + 'px';
            els.canvas.style.height = finalHeight + 'px';

            state.canvasScale = state.image.width / finalWidth;
        }

        function getExportType() {
            const mimeMap = { 'png': 'image/png', 'jpg': 'image/jpeg', 'webp': 'image/webp' };
            return mimeMap[state.exportFormat] || 'image/png';
        }

        function getExportName(exportType) {
            const extMap = { 'image/webp': 'webp', 'image/png': 'png', 'image/jpeg': 'jpg' };
            const ext = extMap[exportType] || 'png';
            if (state.fileName) {
                const base = state.fileName.replace(/\.[^.]+$/, '');
                return `${base}.${ext}`;
            }
            return `magnifier_edit_${Date.now()}.${ext}`;
        }

        function toggleLock() {
            state.isLensLocked = !state.isLensLocked;
            const icon = els.btnLock.querySelector('i');
            const span = els.btnLock.querySelector('span');

            if (state.isLensLocked) {
                icon.className = 'fas fa-lock text-[10px]';
                span.textContent = '位置锁定';
                // Active Capsule Style
                els.btnLock.className = 'group flex items-center gap-1.5 px-3 py-1 rounded-full bg-red-500/20 border border-red-500/30 text-red-400 hover:bg-red-500 hover:text-white transition-all text-[10px] font-medium shadow-[0_0_10px_rgba(239,68,68,0.1)] hover:shadow-[0_0_15px_rgba(239,68,68,0.3)]';
            } else {
                icon.className = 'fas fa-unlock text-[10px]';
                span.textContent = '拖动调整';
                // Inactive Capsule Style
                els.btnLock.className = 'group flex items-center gap-1.5 px-3 py-1 rounded-full bg-white/5 border border-white/10 text-gray-400 hover:bg-white/10 hover:text-gray-200 transition-all text-[10px] font-medium';
            }
            render();
        }

        function updateParams() {
            // Lens Basic
            state.lens.zoom = parseFloat(els.zoom.value);
            state.lens.radius = parseInt(els.size.value) / 2;
            state.lens.aimRadius = parseInt(els.aim.value);

            // Lens Style
            state.lens.borderWidth = parseInt(els.borderW.value);
            state.lens.aimWidth = parseInt(els.aimW.value);
            state.lens.borderColor = els.color.value;

            // Drawing
            state.drawing.color = els.drawColor.value;
            state.drawing.strokeWidth = parseInt(els.drawStrokeWidth.value);
            state.drawing.arrowSize = parseInt(els.drawArrowSize.value);

            // Update the last arrow shape with new arrowSize (real-time editing)
            // AND update the last shape with new strokeWidth (real-time editing)
            if (state.drawing.shapes.length > 0) {
                const lastShape = state.drawing.shapes[state.drawing.shapes.length - 1];

                // Update stroke width for all shapes
                lastShape.strokeWidth = state.drawing.strokeWidth;

                // Update arrow size only for arrows
                if (lastShape.type === 'arrow' || lastShape.type === 'arrow-grow') {
                    lastShape.arrowSize = state.drawing.arrowSize;
                }
            }

            // Update thumb color CSS var for feedback
            document.documentElement.style.setProperty('--thumb-color', state.lens.borderColor);

            // Labels
            els.valZoom.textContent = state.lens.zoom.toFixed(1) + 'x';
            els.valSize.textContent = (state.lens.radius * 2);
            els.valAim.textContent = state.lens.aimRadius;
            els.valQuality.textContent = els.quality.value + '%';
            els.valScale.textContent = Math.round(els.scale.value * 100) + '%';
            els.valBorderW.textContent = state.lens.borderWidth;
            els.valAimW.textContent = state.lens.aimWidth;
            els.valDrawStroke.textContent = state.drawing.strokeWidth;
            els.valArrowSize.textContent = state.drawing.arrowSize;

            render();
        }

        // Update tool button styles based on current tool
        function updateToolButtonStyles() {
            document.querySelectorAll('.draw-tool-btn').forEach(btn => {
                if (btn.dataset.tool === state.drawing.currentTool) {
                    btn.className = 'draw-tool-btn w-9 h-9 rounded-lg flex items-center justify-center transition-all bg-red-500/20 border border-red-500/30 text-red-400 shadow-[0_0_10px_rgba(239,68,68,0.1)]';
                } else {
                    btn.className = 'draw-tool-btn w-9 h-9 rounded-lg flex items-center justify-center transition-all bg-white/5 border border-white/10 text-gray-400 hover:bg-white/10 hover:text-gray-200';
                }
            });
            // Update canvas cursor
            if (state.drawing.currentTool) {
                els.canvas.style.cursor = 'crosshair';
            } else {
                els.canvas.style.cursor = 'default';
            }
        }

        // Draw a filled arrow (similar to annotation style)
        function drawArrow(ctx, fromX, fromY, toX, toY, color, strokeWidth, arrowSize) {
            const angle = Math.atan2(toY - fromY, toX - fromX);
            const headLen = arrowSize;
            const headWidth = arrowSize * 0.6;
            const shaftWidth = strokeWidth * 2;

            ctx.fillStyle = color;
            ctx.strokeStyle = color;
            ctx.lineWidth = 1;

            // Calculate arrow shaft end point (where it meets the arrowhead)
            const shaftEndX = toX - headLen * Math.cos(angle);
            const shaftEndY = toY - headLen * Math.sin(angle);

            // Calculate perpendicular offset for shaft width
            const perpAngle = angle + Math.PI / 2;
            const halfShaft = shaftWidth / 2;

            ctx.beginPath();
            // Start from the base of the arrow (back left)
            ctx.moveTo(fromX + halfShaft * Math.cos(perpAngle), fromY + halfShaft * Math.sin(perpAngle));
            // Go to shaft end (left side)
            ctx.lineTo(shaftEndX + halfShaft * Math.cos(perpAngle), shaftEndY + halfShaft * Math.sin(perpAngle));
            // Go to the left wing of arrowhead
            ctx.lineTo(shaftEndX + headWidth * Math.cos(perpAngle), shaftEndY + headWidth * Math.sin(perpAngle));
            // Go to the tip
            ctx.lineTo(toX, toY);
            // Go to the right wing of arrowhead
            ctx.lineTo(shaftEndX - headWidth * Math.cos(perpAngle), shaftEndY - headWidth * Math.sin(perpAngle));
            // Go to shaft end (right side)
            ctx.lineTo(shaftEndX - halfShaft * Math.cos(perpAngle), shaftEndY - halfShaft * Math.sin(perpAngle));
            // Back to starting point (right side of base)
            ctx.lineTo(fromX - halfShaft * Math.cos(perpAngle), fromY - halfShaft * Math.sin(perpAngle));
            ctx.closePath();
            ctx.fill();
        }

        // Draw a tapered arrow (starts small, ends thick)
        function drawTaperedArrow(ctx, fromX, fromY, toX, toY, color, strokeWidth, arrowSize) {
            const angle = Math.atan2(toY - fromY, toX - fromX);
            const headLen = arrowSize;
            const headWidth = arrowSize * 0.6;

            // Shaft widths
            const startWidth = 2; // Minimal width at the start
            const endWidth = strokeWidth * 3; // Maximum width at the neck

            ctx.fillStyle = color;
            ctx.strokeStyle = color;
            ctx.lineWidth = 1;

            // Calculate arrow shaft end point (where it meets the arrowhead)
            const shaftEndX = toX - headLen * Math.cos(angle);
            const shaftEndY = toY - headLen * Math.sin(angle);

            // Perpendicular angle for width offsets
            const perpAngle = angle + Math.PI / 2;

            ctx.beginPath();

            // 1. Start Point (Tail) - thin
            ctx.moveTo(
                fromX + (startWidth / 2) * Math.cos(perpAngle),
                fromY + (startWidth / 2) * Math.sin(perpAngle)
            );

            // 2. Shaft End (Left) - thick
            ctx.lineTo(
                shaftEndX + (endWidth / 2) * Math.cos(perpAngle),
                shaftEndY + (endWidth / 2) * Math.sin(perpAngle)
            );

            // 3. Arrow Head Left Wing
            ctx.lineTo(
                shaftEndX + headWidth * Math.cos(perpAngle),
                shaftEndY + headWidth * Math.sin(perpAngle)
            );

            // 4. Arrow Tip
            ctx.lineTo(toX, toY);

            // 5. Arrow Head Right Wing
            ctx.lineTo(
                shaftEndX - headWidth * Math.cos(perpAngle),
                shaftEndY - headWidth * Math.sin(perpAngle)
            );

            // 6. Shaft End (Right) - thick
            ctx.lineTo(
                shaftEndX - (endWidth / 2) * Math.cos(perpAngle),
                shaftEndY - (endWidth / 2) * Math.sin(perpAngle)
            );

            // 7. Start Point (Tail) - thin (right side)
            ctx.lineTo(
                fromX - (startWidth / 2) * Math.cos(perpAngle),
                fromY - (startWidth / 2) * Math.sin(perpAngle)
            );

            ctx.closePath();
            ctx.fill();
        }

        // Draw a single shape
        function drawShape(ctx, shape) {
            ctx.strokeStyle = shape.color;
            ctx.lineWidth = shape.strokeWidth;
            ctx.lineCap = 'round';
            ctx.lineJoin = 'round';

            switch (shape.type) {
                case 'rect':
                    ctx.strokeRect(shape.x, shape.y, shape.width, shape.height);
                    break;
                case 'circle':
                    ctx.beginPath();
                    ctx.arc(shape.cx, shape.cy, shape.radius, 0, Math.PI * 2);
                    ctx.stroke();
                    break;
                case 'line':
                    ctx.beginPath();
                    ctx.moveTo(shape.x1, shape.y1);
                    ctx.lineTo(shape.x2, shape.y2);
                    ctx.stroke();
                    break;
                case 'arrow':
                    drawArrow(ctx, shape.x1, shape.y1, shape.x2, shape.y2, shape.color, shape.strokeWidth, shape.arrowSize);
                    break;
                case 'arrow-grow':
                    drawTaperedArrow(ctx, shape.x1, shape.y1, shape.x2, shape.y2, shape.color, shape.strokeWidth, shape.arrowSize);
                    break;
                case 'pen':
                    if (shape.path.length < 2) return;
                    ctx.beginPath();
                    ctx.moveTo(shape.path[0].x, shape.path[0].y);
                    for (let i = 1; i < shape.path.length; i++) {
                        ctx.lineTo(shape.path[i].x, shape.path[i].y);
                    }
                    ctx.stroke();
                    break;
                case 'polyline':
                    if (shape.path.length < 2) return;
                    ctx.beginPath();
                    ctx.moveTo(shape.path[0].x, shape.path[0].y);
                    for (let i = 1; i < shape.path.length; i++) {
                        ctx.lineTo(shape.path[i].x, shape.path[i].y);
                    }
                    ctx.stroke();
                    break;
            }
        }

        function render() {
            if (!state.image) return;

            const w = els.canvas.width;
            const h = els.canvas.height;

            ctx.clearRect(0, 0, w, h);
            ctx.drawImage(state.image, 0, 0, w, h);

            // Draw all completed shapes
            state.drawing.shapes.forEach(shape => drawShape(ctx, shape));

            // Draw current shape being drawn (preview)
            if ((state.drawing.isDrawing || state.drawing.isPolylineActive) && state.drawing.currentTool) {
                const d = state.drawing;
                const pos = state.lastMouse;
                ctx.save();

                switch (d.currentTool) {
                    case 'rect': {
                        const x = Math.min(d.startX, pos.x);
                        const y = Math.min(d.startY, pos.y);
                        const width = Math.abs(pos.x - d.startX);
                        const height = Math.abs(pos.y - d.startY);
                        ctx.strokeStyle = d.color;
                        ctx.lineWidth = d.strokeWidth;
                        ctx.strokeRect(x, y, width, height);
                        break;
                    }
                    case 'circle': {
                        const cx = (d.startX + pos.x) / 2;
                        const cy = (d.startY + pos.y) / 2;
                        const radius = Math.hypot(pos.x - d.startX, pos.y - d.startY) / 2;
                        ctx.strokeStyle = d.color;
                        ctx.lineWidth = d.strokeWidth;
                        ctx.beginPath();
                        ctx.arc(cx, cy, radius, 0, Math.PI * 2);
                        ctx.stroke();
                        break;
                    }
                    case 'line': {
                        ctx.strokeStyle = d.color;
                        ctx.lineWidth = d.strokeWidth;
                        ctx.lineCap = 'round';
                        ctx.beginPath();
                        ctx.moveTo(d.startX, d.startY);
                        ctx.lineTo(pos.x, pos.y);
                        ctx.stroke();
                        break;
                    }
                    case 'arrow': {
                        drawArrow(ctx, d.startX, d.startY, pos.x, pos.y, d.color, d.strokeWidth, d.arrowSize);
                        break;
                    }
                    case 'arrow-grow': {
                        drawTaperedArrow(ctx, d.startX, d.startY, pos.x, pos.y, d.color, d.strokeWidth, d.arrowSize);
                        break;
                    }
                    case 'polyline': {
                        if (d.currentPath.length > 0) {
                            ctx.strokeStyle = d.color;
                            ctx.lineWidth = d.strokeWidth;
                            ctx.lineCap = 'round';
                            ctx.lineJoin = 'round';

                            ctx.beginPath();
                            ctx.moveTo(d.currentPath[0].x, d.currentPath[0].y);
                            for (let i = 1; i < d.currentPath.length; i++) {
                                ctx.lineTo(d.currentPath[i].x, d.currentPath[i].y);
                            }
                            // Preview line to cursor
                            ctx.lineTo(pos.x, pos.y);
                            ctx.stroke();

                            // Draw "nodes" for better visibility
                            ctx.fillStyle = '#fff';
                            d.currentPath.forEach(p => {
                                ctx.beginPath();
                                ctx.arc(p.x, p.y, 2, 0, Math.PI * 2);
                                ctx.fill();
                            });
                        }
                        break;
                    }
                    case 'pen': {
                        if (d.currentPath.length >= 2) {
                            ctx.strokeStyle = d.color;
                            ctx.lineWidth = d.strokeWidth;
                            ctx.lineCap = 'round';
                            ctx.lineJoin = 'round';
                            ctx.beginPath();
                            ctx.moveTo(d.currentPath[0].x, d.currentPath[0].y);
                            for (let i = 1; i < d.currentPath.length; i++) {
                                ctx.lineTo(d.currentPath[i].x, d.currentPath[i].y);
                            }
                            ctx.stroke();
                        }
                        break;
                    }
                }
                ctx.restore();
            }

            // Lens Content
            const lensX = state.lens.x + state.lens.radius;
            const lensY = state.lens.y + state.lens.radius;
            const lensR = state.lens.radius;

            ctx.save();
            ctx.beginPath();
            ctx.arc(lensX, lensY, lensR, 0, Math.PI * 2);
            ctx.clip();
            ctx.fillStyle = '#fff';
            ctx.fill();

            const viewW = (lensR * 2 * state.canvasScale) / state.lens.zoom;
            const viewH = viewW;
            const sx = state.target.x - (viewW / 2);
            const sy = state.target.y - (viewH / 2);

            ctx.drawImage(
                state.image,
                sx, sy, viewW, viewH,
                lensX - lensR, lensY - lensR, lensR * 2, lensR * 2
            );
            ctx.restore();

            // Lens UI
            ctx.save();
            // Border
            ctx.beginPath();
            ctx.arc(lensX, lensY, lensR, 0, Math.PI * 2);
            ctx.lineWidth = state.lens.borderWidth;
            ctx.strokeStyle = state.lens.borderColor;
            ctx.stroke();

            // Aim
            ctx.beginPath();
            ctx.arc(lensX, lensY, state.lens.aimRadius, 0, Math.PI * 2);
            ctx.lineWidth = state.lens.aimWidth;
            ctx.strokeStyle = state.lens.borderColor;
            ctx.stroke();

            // Handle
            if (!state.isLensLocked) {
                const handleAngle = Math.PI * 1.25;
                const handleDist = lensR;
                const handleX = lensX + Math.cos(handleAngle) * handleDist;
                const handleY = lensY + Math.sin(handleAngle) * handleDist;

                ctx.beginPath();
                ctx.arc(handleX, handleY, 14, 0, Math.PI * 2);
                ctx.fillStyle = state.lens.borderColor;
                ctx.fill();
                ctx.strokeStyle = '#fff';
                ctx.lineWidth = 2;
                ctx.stroke();

                ctx.beginPath();
                ctx.moveTo(handleX - 4, handleY);
                ctx.lineTo(handleX + 4, handleY);
                ctx.moveTo(handleX, handleY - 4);
                ctx.lineTo(handleX, handleY + 4);
                ctx.lineWidth = 2;
                ctx.stroke();
            }

            ctx.restore();

            if (state.isDraggingLens) {
                ctx.save();
                ctx.fillStyle = 'rgba(0,0,0,0.6)';
                ctx.beginPath();
                ctx.roundRect(lensX - 40, lensY - lensR - 30, 80, 24, 4);
                ctx.fill();
                ctx.font = '12px Inter, sans-serif';
                ctx.fillStyle = '#fff';
                ctx.textAlign = 'center';
                ctx.fillText("移动镜框", lensX, lensY - lensR - 14);
                ctx.restore();
            }
        }

        // --- Interaction ---
        function getMousePos(evt) {
            const rect = els.canvas.getBoundingClientRect();
            const clientX = evt.touches ? evt.touches[0].clientX : evt.clientX;
            const clientY = evt.touches ? evt.touches[0].clientY : evt.clientY;
            return {
                x: clientX - rect.left,
                y: clientY - rect.top
            };
        }

        function handleMouseDown(e) {
            if (!state.image) return;
            const pos = getMousePos(e);



            if (state.drawing.currentTool === 'eraser') {
                // Update eraser cursor size (visual only for now, or actual cursor)
                // We can use the render function to show an eraser circle
                state.lastMouse = pos;
                state.drawing.isDrawing = true; // "Drawing" with eraser
                eraseShapesAt(pos); // Erase on click
                render();
                return;
            }

            // If a drawing tool is selected, start drawing
            if (state.drawing.currentTool) {
                // If it's polyline, handle click by adding point
                if (state.drawing.currentTool === 'polyline') {
                    if (!state.drawing.isPolylineActive) {
                        state.drawing.isPolylineActive = true;
                        state.drawing.currentPath = [{ x: pos.x, y: pos.y }];
                    } else {
                        state.drawing.currentPath.push({ x: pos.x, y: pos.y });
                    }
                    state.lastMouse = pos;
                    render(); // Render to show new segment/node
                    return;
                }

                state.drawing.isDrawing = true;
                state.drawing.startX = pos.x;
                state.drawing.startY = pos.y;
                if (state.drawing.currentTool === 'pen') {
                    state.drawing.currentPath = [{ x: pos.x, y: pos.y }];
                }
                state.lastMouse = pos;
                return;
            }

            const lensCenterX = state.lens.x + state.lens.radius;
            const lensCenterY = state.lens.y + state.lens.radius;

            const handleAngle = Math.PI * 1.25;
            const handleX = lensCenterX + Math.cos(handleAngle) * state.lens.radius;
            const handleY = lensCenterY + Math.sin(handleAngle) * state.lens.radius;
            const distToHandle = Math.hypot(pos.x - handleX, pos.y - handleY);
            const distToCenter = Math.hypot(pos.x - lensCenterX, pos.y - lensCenterY);

            if (!state.isLensLocked && distToHandle < 20) {
                state.isDraggingLens = true;
                els.canvas.style.cursor = 'move';
            } else if (distToCenter < state.lens.radius) {
                state.isDraggingContent = true;
                els.canvas.style.cursor = 'grab';
            } else if (!state.isLensLocked) {
                state.lens.x = pos.x - state.lens.radius;
                state.lens.y = pos.y - state.lens.radius;
                render();
            }
            state.lastMouse = pos;
        }

        function handleTouchStart(e) { e.preventDefault(); handleMouseDown(e); }

        function handleMouseMove(e) {
            if (!state.image) return;
            const pos = getMousePos(e);

            // Handle drawing
            if (state.drawing.isDrawing && state.drawing.currentTool) {
                if (state.drawing.currentTool === 'pen') {
                    state.drawing.currentPath.push({ x: pos.x, y: pos.y });
                } else if (state.drawing.currentTool === 'eraser') {
                    state.lastMouse = pos;
                    eraseShapesAt(pos);
                    render();
                    return;
                }
                state.lastMouse = pos;
                render();
                return;
            }

            // Eraser hover cursor
            if (state.drawing.currentTool === 'eraser') {
                state.lastMouse = pos;
                render();
                return;
            }

            // Handle polyline preview
            if (state.drawing.currentTool === 'polyline' && state.drawing.isPolylineActive) {
                state.lastMouse = pos;
                render();
                return;
            }

            if (!state.isDraggingLens && !state.isDraggingContent) return;

            const dx = pos.x - state.lastMouse.x;
            const dy = pos.y - state.lastMouse.y;

            if (state.isDraggingLens && !state.isLensLocked) {
                state.lens.x += dx;
                state.lens.y += dy;
            } else if (state.isDraggingContent) {
                state.target.x -= dx * state.canvasScale / state.lens.zoom;
                state.target.y -= dy * state.canvasScale / state.lens.zoom;
            }

            state.lastMouse = pos;
            render();
        }

        function handleTouchMove(e) { e.preventDefault(); handleMouseMove(e); }

        function handleMouseUp() {
            // Stop erasing
            if (state.drawing.currentTool === 'eraser') {
                state.drawing.isDrawing = false;
                return;
            }

            // Special handling for polyline: do NOT finish on mouse up, unless it's not active (logic moved to mousedown/contextmenu)
            if (state.drawing.currentTool === 'polyline') {
                return;
            }

            // Finalize drawing if in progress
            if (state.drawing.isDrawing && state.drawing.currentTool) {
                const d = state.drawing;
                const pos = state.lastMouse;
                let shape = null;

                switch (d.currentTool) {
                    case 'rect': {
                        const x = Math.min(d.startX, pos.x);
                        const y = Math.min(d.startY, pos.y);
                        const width = Math.abs(pos.x - d.startX);
                        const height = Math.abs(pos.y - d.startY);
                        if (width > 2 && height > 2) {
                            shape = { type: 'rect', x, y, width, height, color: d.color, strokeWidth: d.strokeWidth };
                        }
                        break;
                    }
                    case 'circle': {
                        const cx = (d.startX + pos.x) / 2;
                        const cy = (d.startY + pos.y) / 2;
                        const radius = Math.hypot(pos.x - d.startX, pos.y - d.startY) / 2;
                        if (radius > 2) {
                            shape = { type: 'circle', cx, cy, radius, color: d.color, strokeWidth: d.strokeWidth };
                        }
                        break;
                    }
                    case 'line': {
                        const len = Math.hypot(pos.x - d.startX, pos.y - d.startY);
                        if (len > 2) {
                            shape = { type: 'line', x1: d.startX, y1: d.startY, x2: pos.x, y2: pos.y, color: d.color, strokeWidth: d.strokeWidth };
                        }
                        break;
                    }
                    case 'arrow': {
                        const len = Math.hypot(pos.x - d.startX, pos.y - d.startY);
                        if (len > 5) {
                            shape = { type: 'arrow', x1: d.startX, y1: d.startY, x2: pos.x, y2: pos.y, color: d.color, strokeWidth: d.strokeWidth, arrowSize: d.arrowSize };
                        }
                        break;
                    }
                    case 'arrow-grow': {
                        const len = Math.hypot(pos.x - d.startX, pos.y - d.startY);
                        if (len > 5) {
                            shape = { type: 'arrow-grow', x1: d.startX, y1: d.startY, x2: pos.x, y2: pos.y, color: d.color, strokeWidth: d.strokeWidth, arrowSize: d.arrowSize };
                        }
                        break;
                    }
                    case 'pen': {
                        if (d.currentPath.length >= 2) {
                            shape = { type: 'pen', path: [...d.currentPath], color: d.color, strokeWidth: d.strokeWidth };
                        }
                        break;
                    }
                }

                if (shape) {
                    state.drawing.shapes.push(shape);
                }

                state.drawing.isDrawing = false;
                state.drawing.currentPath = [];
                render();
                render();
                return;
            }

            state.isDraggingLens = false;
            state.isDraggingContent = false;
            if (!state.drawing.currentTool) {
                els.canvas.style.cursor = 'default';
            }
        }

        function handleContextMenu(e) {
            if (state.drawing.currentTool === 'polyline' && state.drawing.isPolylineActive) {
                e.preventDefault();
                console.log('Finishing polyline, path length:', state.drawing.currentPath.length);
                // Finish polyline
                if (state.drawing.currentPath.length >= 2) {
                    const shape = {
                        type: 'polyline',
                        path: [...state.drawing.currentPath],
                        color: state.drawing.color,
                        strokeWidth: state.drawing.strokeWidth
                    };
                    state.drawing.shapes.push(shape);
                }

                state.drawing.isPolylineActive = false;
                state.drawing.currentPath = [];
                render();
            }
        }



        function handleKeyDown(e) {
            if (e.key === 'Escape') {
                if (state.drawing.currentTool === 'polyline' && state.drawing.isPolylineActive) {
                    // Cancel polyline
                    state.drawing.isPolylineActive = false;
                    state.drawing.currentPath = [];
                    render();
                }
            }
        }

        // --- Eraser Logic ---
        function eraseShapesAt(pos) {
            const eraserSize = state.drawing.strokeWidth * 5; // Eraser size multiplier
            const eraserRadius = eraserSize / 2;

            // Filter out shapes that collide with eraser
            // We iterate backwards to prioritize top shapes (though simple filter is easier)
            const initialCount = state.drawing.shapes.length;
            state.drawing.shapes = state.drawing.shapes.filter(shape => !isShapeHit(shape, pos, eraserRadius));

            if (state.drawing.shapes.length !== initialCount) {
                // Something was erased
            }
        }

        function isShapeHit(shape, pos, radius) {
            // Simple hit testing
            switch (shape.type) {
                case 'circle': {
                    const dist = Math.hypot(pos.x - shape.cx, pos.y - shape.cy);
                    return dist < (shape.radius + radius + shape.strokeWidth / 2);
                }
                case 'rect': {
                    // Check if point is near rect borders
                    // A simple bounding box check + expansion for now
                    // Ideally we check distance to rectangle edges
                    const innerX = shape.x - radius - shape.strokeWidth / 2;
                    const innerY = shape.y - radius - shape.strokeWidth / 2;
                    const innerW = shape.width + (radius + shape.strokeWidth / 2) * 2;
                    const innerH = shape.height + (radius + shape.strokeWidth / 2) * 2;

                    const inBox = pos.x >= innerX && pos.x <= innerX + innerW &&
                        pos.y >= innerY && pos.y <= innerY + innerH;

                    if (!inBox) return false;

                    // More precise: check if inside rect (filled?) or near edges?
                    // Assuming hollow rects for reticle
                    // Dist to left
                    const dL = Math.abs(pos.x - shape.x);
                    const dR = Math.abs(pos.x - (shape.x + shape.width));
                    const dT = Math.abs(pos.y - shape.y);
                    const dB = Math.abs(pos.y - (shape.y + shape.height));

                    // Check if within horizontal/vertical bands
                    const onVert = (pos.y >= shape.y - radius && pos.y <= shape.y + shape.height + radius);
                    const onHorz = (pos.x >= shape.x - radius && pos.x <= shape.x + shape.width + radius);

                    if (onVert && (dL <= radius + shape.strokeWidth || dR <= radius + shape.strokeWidth)) return true;
                    if (onHorz && (dT <= radius + shape.strokeWidth || dB <= radius + shape.strokeWidth)) return true;

                    return false;
                }
                case 'line': {
                    return distanceToSegment(pos, { x: shape.x1, y: shape.y1 }, { x: shape.x2, y: shape.y2 }) <= radius + shape.strokeWidth / 2;
                }
                case 'arrow':
                case 'arrow-grow': {
                    // Approximate with line segment for shaft extended to tip
                    return distanceToSegment(pos, { x: shape.x1, y: shape.y1 }, { x: shape.x2, y: shape.y2 }) <= radius + shape.arrowSize / 2;
                }
                case 'pen':
                case 'polyline': {
                    // Check all segments
                    if (shape.path.length < 2) return false;
                    for (let i = 0; i < shape.path.length - 1; i++) {
                        if (distanceToSegment(pos, shape.path[i], shape.path[i + 1]) <= radius + shape.strokeWidth / 2) {
                            return true;
                        }
                    }
                    return false;
                }
            }
            return false;
        }

        function distanceToSegment(p, v, w) {
            const l2 = (w.x - v.x) ** 2 + (w.y - v.y) ** 2;
            if (l2 === 0) return Math.hypot(p.x - v.x, p.y - v.y);
            let t = ((p.x - v.x) * (w.x - v.x) + (p.y - v.y) * (w.y - v.y)) / l2;
            t = Math.max(0, Math.min(1, t));
            const proj = { x: v.x + t * (w.x - v.x), y: v.y + t * (w.y - v.y) };
            return Math.hypot(p.x - proj.x, p.y - proj.y);
        }

        // 生成导出画布，复用给下载与复制
        function buildExportCanvas() {
            if (!state.image) return null;

            const scale = parseFloat(els.scale.value);
            const quality = parseInt(els.quality.value) / 100;

            const exportCanvas = document.createElement('canvas');
            const eCtx = exportCanvas.getContext('2d');

            const finalW = state.image.width * scale;
            const finalH = state.image.height * scale;

            exportCanvas.width = finalW;
            exportCanvas.height = finalH;

            const previewW = els.canvas.width;
            const ratio = finalW / previewW;

            const exportLensR = state.lens.radius * ratio;
            const exportLensX = state.lens.x * ratio;
            const exportLensY = state.lens.y * ratio;
            const exportAimR = state.lens.aimRadius * ratio;

            eCtx.drawImage(state.image, 0, 0, finalW, finalH);

            // Draw all shapes (scaled)
            state.drawing.shapes.forEach(shape => {
                eCtx.strokeStyle = shape.color;
                eCtx.lineWidth = shape.strokeWidth * ratio;
                eCtx.lineCap = 'round';
                eCtx.lineJoin = 'round';

                switch (shape.type) {
                    case 'rect':
                        eCtx.strokeRect(shape.x * ratio, shape.y * ratio, shape.width * ratio, shape.height * ratio);
                        break;
                    case 'circle':
                        eCtx.beginPath();
                        eCtx.arc(shape.cx * ratio, shape.cy * ratio, shape.radius * ratio, 0, Math.PI * 2);
                        eCtx.stroke();
                        break;
                    case 'line':
                        eCtx.beginPath();
                        eCtx.moveTo(shape.x1 * ratio, shape.y1 * ratio);
                        eCtx.lineTo(shape.x2 * ratio, shape.y2 * ratio);
                        eCtx.stroke();
                        break;
                    case 'arrow': {
                        // Use same filled arrow style as drawArrow
                        const angle = Math.atan2(shape.y2 - shape.y1, shape.x2 - shape.x1);
                        const headLen = shape.arrowSize * ratio;
                        const headWidth = shape.arrowSize * 0.6 * ratio;
                        const shaftWidth = shape.strokeWidth * 2 * ratio;

                        const fromX = shape.x1 * ratio;
                        const fromY = shape.y1 * ratio;
                        const toX = shape.x2 * ratio;
                        const toY = shape.y2 * ratio;

                        const shaftEndX = toX - headLen * Math.cos(angle);
                        const shaftEndY = toY - headLen * Math.sin(angle);

                        const perpAngle = angle + Math.PI / 2;
                        const halfShaft = shaftWidth / 2;

                        eCtx.fillStyle = shape.color;
                        eCtx.beginPath();
                        eCtx.moveTo(fromX + halfShaft * Math.cos(perpAngle), fromY + halfShaft * Math.sin(perpAngle));
                        eCtx.lineTo(shaftEndX + halfShaft * Math.cos(perpAngle), shaftEndY + halfShaft * Math.sin(perpAngle));
                        eCtx.lineTo(shaftEndX + headWidth * Math.cos(perpAngle), shaftEndY + headWidth * Math.sin(perpAngle));
                        eCtx.lineTo(toX, toY);
                        eCtx.lineTo(shaftEndX - headWidth * Math.cos(perpAngle), shaftEndY - headWidth * Math.sin(perpAngle));
                        eCtx.lineTo(shaftEndX - halfShaft * Math.cos(perpAngle), shaftEndY - halfShaft * Math.sin(perpAngle));
                        eCtx.lineTo(fromX - halfShaft * Math.cos(perpAngle), fromY - halfShaft * Math.sin(perpAngle));
                        eCtx.closePath();
                        eCtx.fill();
                        break;
                    }
                    case 'arrow-grow': {
                        // Re-implement drawTaperedArrow logic for export (scaled)
                        const angle = Math.atan2(shape.y2 - shape.y1, shape.x2 - shape.x1);
                        const headLen = shape.arrowSize * ratio;
                        const headWidth = shape.arrowSize * 0.6 * ratio;

                        const startWidth = 2 * ratio;
                        const endWidth = shape.strokeWidth * 3 * ratio;

                        const fromX = shape.x1 * ratio;
                        const fromY = shape.y1 * ratio;
                        const toX = shape.x2 * ratio;
                        const toY = shape.y2 * ratio;

                        const shaftEndX = toX - headLen * Math.cos(angle);
                        const shaftEndY = toY - headLen * Math.sin(angle);
                        const perpAngle = angle + Math.PI / 2;

                        eCtx.fillStyle = shape.color;
                        eCtx.beginPath();

                        // 1. Tail (thin)
                        eCtx.moveTo(fromX + (startWidth / 2) * Math.cos(perpAngle), fromY + (startWidth / 2) * Math.sin(perpAngle));
                        // 2. Shaft end (thick)
                        eCtx.lineTo(shaftEndX + (endWidth / 2) * Math.cos(perpAngle), shaftEndY + (endWidth / 2) * Math.sin(perpAngle));
                        // 3. Head L
                        eCtx.lineTo(shaftEndX + headWidth * Math.cos(perpAngle), shaftEndY + headWidth * Math.sin(perpAngle));
                        // 4. Tip
                        eCtx.lineTo(toX, toY);
                        // 5. Head R
                        eCtx.lineTo(shaftEndX - headWidth * Math.cos(perpAngle), shaftEndY - headWidth * Math.sin(perpAngle));
                        // 6. Shaft end (thick)
                        eCtx.lineTo(shaftEndX - (endWidth / 2) * Math.cos(perpAngle), shaftEndY - (endWidth / 2) * Math.sin(perpAngle));
                        // 7. Tail (thin)
                        eCtx.lineTo(fromX - (startWidth / 2) * Math.cos(perpAngle), fromY - (startWidth / 2) * Math.sin(perpAngle));

                        eCtx.closePath();
                        eCtx.fill();
                        break;
                    }
                    case 'polyline':
                        if (shape.path.length >= 2) {
                            eCtx.beginPath();
                            eCtx.moveTo(shape.path[0].x * ratio, shape.path[0].y * ratio);
                            for (let i = 1; i < shape.path.length; i++) {
                                eCtx.lineTo(shape.path[i].x * ratio, shape.path[i].y * ratio);
                            }
                            eCtx.stroke();
                        }
                        break;
                    case 'pen':
                        if (shape.path.length >= 2) {
                            eCtx.beginPath();
                            eCtx.moveTo(shape.path[0].x * ratio, shape.path[0].y * ratio);
                            for (let i = 1; i < shape.path.length; i++) {
                                eCtx.lineTo(shape.path[i].x * ratio, shape.path[i].y * ratio);
                            }
                            eCtx.stroke();
                        }
                        break;
                }
            });

            const lensCenterX = exportLensX + exportLensR;
            const lensCenterY = exportLensY + exportLensR;

            eCtx.save();
            eCtx.beginPath();
            eCtx.arc(lensCenterX, lensCenterY, exportLensR, 0, Math.PI * 2);
            eCtx.clip();
            eCtx.fillStyle = '#fff';
            eCtx.fill();

            const viewW = (state.lens.radius * 2 * state.canvasScale) / state.lens.zoom;
            const viewH = viewW;
            const sx = state.target.x - (viewW / 2);
            const sy = state.target.y - (viewH / 2);

            eCtx.drawImage(
                state.image,
                sx, sy, viewW, viewH,
                exportLensX, exportLensY, exportLensR * 2, exportLensR * 2
            );
            eCtx.restore();

            eCtx.save();
            eCtx.beginPath();
            eCtx.arc(lensCenterX, lensCenterY, exportLensR, 0, Math.PI * 2);
            eCtx.lineWidth = state.lens.borderWidth * ratio;
            eCtx.strokeStyle = state.lens.borderColor;
            eCtx.stroke();

            eCtx.beginPath();
            eCtx.arc(lensCenterX, lensCenterY, exportAimR, 0, Math.PI * 2);
            eCtx.lineWidth = state.lens.aimWidth * ratio;
            eCtx.strokeStyle = state.lens.borderColor;
            eCtx.stroke();
            eCtx.restore();

            return { exportCanvas, quality };
        }

        function downloadImage() {
            const result = buildExportCanvas();
            if (!result) return;
            const { exportCanvas, quality } = result;
            const exportType = getExportType();

            const dataURL = exportCanvas.toDataURL(exportType, quality);
            const downloadName = getExportName(exportType);
            const link = document.createElement('a');
            link.download = downloadName;
            link.href = dataURL;
            link.click();
        }

        async function copyImage() {
            const result = buildExportCanvas();
            if (!result) return;
            const { exportCanvas, quality } = result;

            if (!navigator.clipboard || !navigator.clipboard.write || typeof ClipboardItem === 'undefined') {
                alert('当前环境不支持剪贴板复制。');
                return;
            }

            try {
                let mimeCandidates = [
                    { type: 'image/png', quality: 1 },
                    { type: 'image/jpeg', quality }
                ];

                if (typeof ClipboardItem?.supports === 'function') {
                    mimeCandidates = mimeCandidates.filter(c => ClipboardItem.supports(c.type));
                }

                const blobEntries = [];
                for (const candidate of mimeCandidates) {
                    const blob = await new Promise(resolve => exportCanvas.toBlob(resolve, candidate.type, candidate.quality));
                    if (blob) {
                        blobEntries.push([candidate.type, blob]);
                    }
                }

                if (blobEntries.length === 0) {
                    alert('导出图片失败，当前环境不支持 JPG/PNG 剪贴板写入。');
                    return;
                }

                await navigator.clipboard.write([
                    new ClipboardItem(Object.fromEntries(blobEntries))
                ]);

                els.copyBtn.textContent = '已复制';
                setTimeout(() => { els.copyBtn.innerHTML = '<i class="fas fa-copy"></i> <span class="hidden sm:inline">复制</span>'; }, 1200);
            } catch (err) {
                alert('复制到剪贴板失败：' + err.message);
            }
        }

        init();
    </script>
</body>

</html>